<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/vue"></script>
  <script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
  <title>review</title>
  <style>
    body {
      background: #fdfcf8;
    }

    .box {
      margin: 10px auto;
    }

    a {
      font-size: 12px;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div id="app">
    <div @click='showall' class="a">toggle</div>
    <div>
      <h5>js</h5>
      <div v-for='(item,index) in jsquestion' class="box">
        <div>{{index+1}}. {{item.q}} <span style="color: red;cursor: pointer;font-size: 12px;" @click='showans'>查看解析</span></div>
        <div>
          <textarea cols=50></textarea>
        </div>
        <div v-html='item.a' class="answers" style="display: none;"></div>
      </div>
    </div>

    <div>
      <h5>css</h5>
      <div v-for='(item,index) in cssquestion' class="box">
        <div>{{index+1}}. {{item.q}} <span style="color: red;cursor: pointer;font-size: 12px;" @click='showans'>查看解析</span></div>
        <div>
          <textarea cols=50></textarea>
        </div>
        <div v-html='item.a' class="answers" style="display: none;"></div>
      </div>
    </div>

    <div>
      <h5>es6</h5>
      <div v-for='(item,index) in es6question' class="box">
        <div>{{index+1}}. {{item.q}} <span style="color: red;cursor: pointer;font-size: 12px;" @click='showans'>查看解析</span></div>
        <div>
          <textarea cols=50></textarea>
        </div>
        <div v-html='item.a' class="answers" style="display: none;"></div>
      </div>
    </div>

    <div>
      <h5>浏览器</h5>
      <div v-for='(item,index) in browser' class="box">
        <div>{{index+1}}. {{item.q}} <span style="color: red;cursor: pointer;font-size: 12px;" @click='showans'>查看解析</span></div>
        <div>
          <textarea cols=50></textarea>
        </div>
        <div v-html='item.a' class="answers" style="display: none;"></div>
      </div>
    </div>

    <div>
      <h5>vue</h5>
      <div v-for='(item,index) in vue' class="box">
        <div>{{index+1}}. {{item.q}} <span style="color: red;cursor: pointer;font-size: 12px;" @click='showans'>查看解析</span></div>
        <div>
          <textarea cols=50></textarea>
        </div>
        <div v-html='item.a' class="answers" style="display: none;"></div>
      </div>
    </div>

  </div>

  <script>
    var app = new Vue({
      el: '#app',
      data: {
        jsquestion: [{
          q: 'js数据类型',
          a: `1.值类型(基本类型): String , Number , Boolean , Null , Undefined , Symbol
              <br />2.引用数据类型: Object , Array , Function`
        },{
          q: '怎么判断数据类型',
          a: `1.typeof。 判断变量类型，可以检测出string、number、function、undefined、boolean,但无法判断出object中的对象、数组等方法。typeof null 也等于 object
              <br />2.instanceof。 检测对象数据类型（js中一切接对象） 表示当左侧为右侧的实例时返回true ( a instanceof String)
              <br />3.Object.prototype.toString.call()。 能准确判断类型 (Object.prototype.toString.call(a) === '[object String]')
              <br />4.constructor。 为实例原型上的方法，指向他的构造函数 ( a.constructor === Array)
              <br />5.jQuery.type()。 函数用于确定JavaScript内置对象的类型，并返回小写形式的类型名称`
        }, {
          q: '闭包',
          a: `定义：当一个嵌套的内部函数引用了外部函数的变量或者函数时，外部函数在执行时就产生了闭包。
              <br />闭包指的是：能够访问另一个函数作用域的变量的函数。清晰的讲：闭包就是一个函数，这个函数能够访问其他函数的作用域中的变量
              <br />闭包的三个特性： 
              <br />1.函数嵌套函数
              <br />2.函数内部可以引用外部的参数和变量
              <br />3.参数和变量不会被垃圾回收机制回收`
        }, {
          q: 'callee,caller,call,apply和bind',
          a: `callee: callee是一个指针，指向拥有这个argument对象的函数,callee 属性是 arguments 对象的一个成员，它表示对函数对象本身的引用
              <br />caller: caller这个属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。
              <br />apply:是改变函数执行的作用域的，说的通俗点就是改变函数体内this的指向，apply第二个参数可以是Array实例，也可以是argument对象
              <br />call:也是改变函数执行的作用域的，和apply一样，不同的是call的接受参数必须逐个列出来
              <br />bind:这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值
              <div><a href='https://blog.csdn.net/yc123h/article/details/52729484'>参考连接</a></div>`
        },{
          q: 'new操作符原理',
          a: `1.创建一个空对象
              <br />2.将空对象的原型指向构造函数的原型
              <br />3.将空对象作为构造函数的上下文(改变this指向)
              <br />4.对构造函数有返回值的判断
              <div><img src='./new.jpg'><div>
              <div><a href='https://zhuanlan.zhihu.com/p/158640941'>参考连接</a></div>`
        }, {
          q: 'js继承方式',
          a: `1.构造函数继承
              <br />2.原型实例继承
              <br />3.原型直接继承
              <br />4.ES6中Class继承
              <div><a href="https://zhuanlan.zhihu.com/p/81266626">参考连接</a></div>`
        }, {
          q: '深拷贝和浅拷贝',
          a: `浅拷贝：就是简单的复制,就相当于把一个对象中的所有的内容,复制一份给另一个对象。
              <br />深拷贝: 把一个对象的属性和方法一个个找出来，在另一个对象中开辟对应的空间，一个个存储到另一个对象中。
              <br />实现深拷贝的方法:
              <br />1.通过 JSON 对象实现深拷贝 ( _Obj = JSON.stringify(obj), cloneObj = JSON.parse(_Obj) )
              <br />2.通过jQuery的extend方法实现深拷贝 ( newArray = $.extend([deep],target,object1[,objectN]) 
              <br />      deep表示为true是深拷贝。 target目标对象，其他对象的成员属性将被加到该对象上。 object1,objectN可选，被合并拷贝的对象
              <br />3.Object.assign() 当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝 ( obj = Object.assign({},obj) )
              <br />4.使用递归实现
              <div><img src='./deepclone.jpg'></div>`
        }, {
          q: '防抖(debounce)和节流(throttle)',
          a: `防抖：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定时间到来之前，又触发了事件，就重新开始延时
              <br />节流：当持续触发事件时，保证在一定时间内只调用一次事件处理函数，意思就是说，假设一个用户一直触发这个函数，且每次触发小于既定值，函数节流会每隔这个时间调用一次
              <br />用一句话总结防抖和节流的区别：防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行
              <br />实现函数节流我们主要有两种方法：时间戳和定时器`
        }, {
          q: '重绘和重排(回流)',
          a: `浏览器解析页面的过程
              <br />首先加载dom结构形成dom树-->然后加载css-->dom树和css结合形成render树 -->渲染页面
              <br />当改变样式（不改变大小）的时候，从render树开始重新开始渲染页面，这就是重绘
              <br />当改变dom结构的时候，会从dom树开始从新渲染页面，这就是重排
              <br />重排和重绘都会影响性能
              <br />解决方案:
              <br />1.如果是在页面的末尾修改dom直接用字符串拼接到原有结构的后面即可
              <br />2.避免多次修改dom结构或者css,集中处理，只引发一次重绘或者重排`
        }, {
          q: 'js设计模式',
          a: `1.工厂模式：工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。
              &nbsp&nbsp工厂模式是用来创建对象的一种最常用的设计模式。我们不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。
              <br />2..单例模式:限制类实例化次数只能一次，一个类只有一个实例，并提供一个访问它的全局访问点。
              <br />3.原型模式: 是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。
              <br />4.适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
              <br />5.代理模式: 为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
              <br />6.发布-订阅模式： 基于一个事件（主题）通道，希望接收通知的对象 Subscriber 通过自定义事件订阅主题，被激活事件的对象 Publisher 通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象。
              <br />7.策略模式：定义一系列的算法，把它们一个个封装起来，并使它们可以替换。
              <br />8.迭代器模式：迭代器模式是指一种顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，
              &nbsp&nbsp即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。
              <br />9.观察者模式：定义了对象间一种一对多的依赖关系（一个目标者，即：被观察者，多个观察者），当目标对象 Subject 的状态发生改变时，所有依赖它的对象 Observer 都会得到通知。
              <br />10.命令模式：请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。
              <br />11.组合模式：又叫 “部分整体” 模式，将对象组合成树形结构，以表示 “部分-整体” 的层次结构。通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。
              <br />12.建造者模式：是将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。
              <div> <a href='https://blog.csdn.net/weixin_46124214/article/details/105066290' target='_blank' style='font-size:12px'>参考链接 </div>`
        }, {
          q: '原型链',
          a: `1、原型链是JS特有的一种继承机制
              <br />2.所有原型链的终点都是 Object 函数的 prototype 属性,指向最终顶端 null
              <br />3、每一个构造函数都拥有一个 prototype 属性，此属性指向一个对象，也就是原型对象，原型对象默认拥有一个 constructor 属性，指向指向它的那个构造函数
              <br />   每个对象都拥有一个隐藏的属性 __ proto __，指向它的原型对象
              <br />4、应用场景：继承
              <br />5、优点：把相同或类似的方法写在原型上，方便实例化对象复用
              <div><img src='./yuanxinglian.jpg'></div>`
        }, {
          q: '跨域的方式',
          a: `跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的
              <br />同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。
              <br />&nbsp&nbsp&nbsp&nbsp所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。
              <br />跨域的方法:
              <br />1.通过jsonp跨域:通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，
              <br />&nbsp&nbsp&nbsp&nbsp基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 
              <br />&nbsp&nbsp&nbsp&nbsp缺点：jsonp缺点：只能实现get一种请求
              <br />2.document.domain + iframe 跨域:此方案仅限主域相同，子域不同的跨域应用场景.
              <br />&nbsp&nbsp&nbsp&nbsp实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。
              <br />3.location.hash + iframe 跨域
              <br />&nbsp&nbsp&nbsp&nbsp实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
              <br />4.window.name + iframe跨域
              <br />&nbsp&nbsp&nbsp&nbspwindow.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值(2MB)
              <br />5.postMessage跨域
              <br />6.跨域资源共享（CORS）
              <br />7.Nodejs中间件代理跨域
              <br />8.WebSocket协议跨域
              <br />9.nginx代理跨域
              <div><a href="https://www.cnblogs.com/ly1368489670/p/13924122.html" style="font-size:12px">跨域方式参考连接</a>  
                <a href='http://www.ruanyifeng.com/blog/2016/04/cors.html' style="font-size:12px">跨域资源共享 CORS 详解</a></div>`
        }, {
          q: 'require和import的区别',
          a: `1.加载方式不同、规范不同。require是在运行是加载，是CommentJS/AMD规范；import是编译时加载，是ESMScript6+规范。
              <br />2.require输出是值的拷贝，import输出是值的引用。`
        },{
          q: 'EventLoop',
          a: `JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。
              <br />如果前一个任务耗时很长，后一个任务就不得不一直等着。
              <br />如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），
              <br />不得不等着结果出来，再往下执行。
              <br />JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。
              <br />于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，
              <br />才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
              <br />具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）
              <br />（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
              <br />（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
              <br />（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
              <br />（4）主线程不断重复上面的第三步。
              <div><img src="./EventLoop.jpg"></div>`
        },{
          q: `{}、new Object()，Object.create({})的区别`,
          a: `Object.create(null) 创建的对象是一个空对象，在该对象上没有继承 Object.prototype 原型链上的属性或者方法,例如：toString(), hasOwnProperty()等方法
              <br /> {}是javascript对象字面量创建的形式，其本质和new Object()并无区别，默认都是继承了Object对象上的prototype`
        },{
          q: `webpack面试题`,
          a: `<div><a href="https://www.cnblogs.com/gaoht/p/11310365.html">参考链接</a></div>`
        },{
          q: '常见面试题',
          a: `<div><a href="https://juejin.cn/post/6844903776512393224#heading-4">参考链接1</a></div>
              <div><a href="http://www.360doc.com/content/20/0412/09/31263000_905424606.shtml">参考链接2</a></div>`
        }],
        cssquestion: [{
          q: 'css盒模型',
          a: `W3C标准盒模型(content-box)：属性width,height只包含内容content，不包含border和padding
              <br />IE盒模型(border-box)：属性width,height包含border和padding，指的是content+padding+border`
        }, {
          q: 'flex',
          a: `容器属性： 
              <br />flex-direction： row | row-reverse | colomn | colomn-reverse 决定主轴方向
              <br />flex-wrap: nowrap | wrap | wrap-reverse 是否换行
              <br />flex-flow: flex-direction || flex-wrap
              <br />justify-content: flex-start | flex-end | center | space-between | space-around 定义了项目在主轴上的对齐方式
              <br />align-items: flex-start | flex-end | center | baseline | stretch 定义了项目在交叉轴上如何对齐
              <br />align-content: flex-start | flex-end | center | space-between | space-around | stretch 定义了多根轴线的对其方式,若只有一根轴线则该属性无效
              <br />项目属性：
              <br />order: 'integer' 定义项目的排列顺序，数值越小，排列越前
              <br />flex-grow: 'number' 定义项目的放大比例,默认为0，即如果存在剩余空间，也不放大
              <br />flex-shrink: 'number' 定义项目的缩小比例，默认为1,即如果空间不足，该项目将缩小
              <br />flex-basis: 'length' 定义了在分配多余空间之前，项目占据的主轴空间。默认值为auto，即项目本来大小
              <br />flex: ['flex-grow' 'flex-shrink' 'flex-basis'] flex为三个属性的简写，默认为 0 1 auto
              <br />align-self: auto | flex-start | flex-end | center | baseline | stretch 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性
              <div><a href="https://www.cnblogs.com/hellocd/p/10443237.html" style="font-size:12px">参考连接</div>`
        }, {
          q: 'grid(栅格布局)',
          a: `<div><a href='http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html' style='font-size:12px;'>参考链接</div>`
        }, {
          q: 'BFC(Block Formatting Context)和IFC(inline Formatting Context)',
          a: `BFC(块级格式化上下文):
              <br />1.内部的盒子会在垂直的方向，一个个地放置
              <br />2.盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的上下margin会发生重叠
              <br />3.每个元素的左边，与包含的盒子的左边相接触，即使存在浮动元素也是如此
              <br />4.BFC的区域不会与float重叠
              <br />5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此
              <br />6.计算BFC的高度时，浮动元素也参与计算
              <br />触发条件：
              <br />1.float的属性不为none
              <br />2.postition为absolute或fixed
              <br />3.display为inline-block、table-cell、table-caption、flex
              <br />4.overflow不为visible
              <br />IFC(行级格式化上下文)：
              <br />1.内部的盒子会在水平方向，一个个地放置
              <br />2.IFC的高度，由里面最高盒子的高度决定
              <br />3.当一行不够放置的时候回自动切换到下一行`
        }, {
          q: '水平垂直居中',
          a: `1.绝对定位
              <br />position:absolute;
              <br />top:50%;
              <br />left:50%
              <br />transform:translate(-50%, -50%)
              <br />2.flex
              <br />display:flex;
              <br />justify-content: center;
              <br />align-items: center;
              <br />3.table-cell
              <br />display: table-cell;
              <br />vertical-align: middle;
              <br />text-align: center;`
        }, {
          q: '文字超出显示省略号',
          a: `单行：
              <br />overflow: hidden;
              <br />text-overflow: ellipsis;
              <br />white-space: nowrap;
              <br />多行：(因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端)
              <br />display: -webkit-box;
              <br />-webkit-box-orient: vertical;
              <br />-webkit-line-clamb: 3;
              <br />overflow: hidden;`
        }, {
          q: '清楚浮动',
          a: `1.在浮动元素后面添加一个空元素样式为clear:both
              <br />2.给浮动元素的容器添加overflow:hidden/auto 使浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。可以清除浮动.另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1
              <br />3.给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局
              <br />4.给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动`
        }, {
          q: 'css优化技巧',
          a: `1.合理使用选择器
              <br />2.减少DOM操作，减少重绘和重排
              <br />3.去除无效的选择器
              <br />4.文件压缩
              <br />5.异步加载文件
              <br />6.减少@import的使用`
        }, {
          q: 'px/em/rem/vh/vw',
          a: `px: 像素(Pixel)，相对长度单位。像素px是相对于显示器屏幕的分辨率而言的
              <br />em: em是相对长度单位。相当于当前父元素的字体尺寸，如未设置，则相对于浏览器的默认字体尺寸
              <br />rem: rem是css3新增的一个相对单位。使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素
              <br />vh： css3新单位，view height的简写，是指可视窗口的高度，假如高度是1200px的话，那10vh就是120px
              <br />vw： css3新单位，view width的简写，是指可视窗口的宽度，假如宽度是1200px的话，那10vw就是120px`
        }, {
          q: 'css的继承属性',
          a: `
              一、无继承性的属性
              <br />1、display：规定元素应该生成的框的类型
              <br />2、文本属性：
              <br />vertical-align：垂直文本对齐
              <br />text-decoration：规定添加到文本的装饰
              <br />text-shadow：文本阴影效果
              <br />white-space：空白符的处理
              <br />unicode-bidi：设置文本的方向
              <br />3、盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left
              <br />4、背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment
              <br />5、定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index
              <br />6、生成内容属性：content、counter-reset、counter-increment
              <br />7、轮廓样式属性：outline-style、outline-width、outline-color、outline
              <br />8、页面样式属性：size、page-break-before、page-break-after
              <br />9、声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during
              <br />二、有继承性的属性
              <br />1、字体系列属性
              <br />font：组合字体
              <br />font-family：规定元素的字体系列
              <br />font-weight：设置字体的粗细
              <br />font-size：设置字体的尺寸
              <br />font-style：定义字体的风格
              <br />font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。
              <br />font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。
              <br />font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。
              <br />2、文本系列属性
              <br />text-indent：文本缩进
              <br />text-align：文本水平对齐
              <br />line-height：行高
              <br />word-spacing：增加或减少单词间的空白（即字间隔）
              <br />letter-spacing：增加或减少字符间的空白（字符间距）
              <br />text-transform：控制文本大小写
              <br />direction：规定文本的书写方向
              <br />color：文本颜色
              <br />3、元素可见性：visibility
              <br />4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout
              <br />5、列表布局属性：list-style-type、list-style-image、list-style-position、list-style
              <br />6、生成内容属性：quotes
              <br />7、光标属性：cursor
              <br />8、页面样式属性：page、page-break-inside、windows、orphans
              <br />9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation
              <br />三、所有元素可以继承的属性
              <br />1、元素可见性：visibility
              <br />2、光标属性：cursor
              <br />四、内联元素可以继承的属性
              <br />1、字体系列属性
              <br />2、除text-indent、text-align之外的文本系列属性
              <br />五、块级元素可以继承的属性
              <br />1、text-indent、text-align
          `
        },{
          q: `CSS渲染的详细过程`,
          a: `1.处理HTML标记并构建DOM树
              <br />2.处理CSS标记并构建CSSOM树
              <br />3.将DOM与CSSOM合并成一个渲染树
              <br />4.根据渲染树来布局，以计算每个节点的几何信息
              <br />5.将各个节点绘制到屏幕上
              <div><a href="https://zhuanlan.zhihu.com/p/40727066" style="font-size:12px">参考连接</a>  <a href="https://zhuanlan.zhihu.com/p/40727066">参考连接</a></div>`
        }],
        es6question: [{
          q: '箭头函数和普通函数的区别',
          a: `主要区别在this的指向:
              <br />1.普通函数的this指向调用它的那个对象。this总是代表它的直接调用者,没找到直接调用者,则this指的是 window(匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window)。
              <br />2.箭头函数不能作为构造函数，不能使用new，没有this，arguments箭头函数，箭头函数的this永远指向其上下文的this，任何方法都改变不了其指向，如call()，bind()，apply()
              <br />（或者说箭头函数中的this指向的是定义时的this，而不是执行时的this）
              <br />箭头函数中this对象，就是定义时所在的对象，而不是使用时所在的对象，箭头函数中没有自己的this的，而箭头函数会默认使用父级的this。
              <br />首先到它的父作用域找，如果父作用域还是箭头函数，那么接着向上找，直到找到我们要的this指向`
        }, {
          q: 'es6的新特性',
          a: ``
        }, {
          q: 'promise',
          a: ``
        },{
          q: 'map,weakmap和set,weakset',
          a: `set: 类似于数组，但它的成员的值都是唯一的，没有重复的值。它可以用于数组去重。
          <br />&nbsp&nbsp向Set加入值的时候，不会发生类型转换，所以 5 和 '5' 是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做'Same-value-zero equality'，类似于精确相等运算符'==='，
          <br />主要区别是向Set加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。
          <br />&nbsp&nbspSet结构的实例有以下属性：
          <br />&nbsp&nbsp操作方法：
          <br />&nbsp&nbsp&nbsp&nbsp -Set.prototype.contructor:构造函数，默认就是Set函数
          <br />&nbsp&nbsp&nbsp&nbsp -Set.prototype.size: 返回Set实例的成员数量
          <br />&nbsp&nbsp&nbsp&nbsp -Set.prototype.add(value): 添加某个值，返回Set本身
          <br />&nbsp&nbsp&nbsp&nbsp -Set.prototype.delete(value): 删除某个值，返回一个布尔值，表示删除是否
          <br />&nbsp&nbsp&nbsp&nbsp -Set.prototype.has(value): 返回一个布尔值，表示该值是否为Set的成员
          <br />&nbsp&nbsp&nbsp&nbsp -Set.prototype.clear(): 清除所有成员，没有返回值。
          <br />&nbsp&nbsp遍历属性：
          <br />&nbsp&nbsp&nbsp&nbsp -Set.prototype.keys(): 返回键名的遍历器
          <br />&nbsp&nbsp&nbsp&nbsp -Set.prototype.values(): 返回键值的遍历器
          <br />&nbsp&nbsp&nbsp&nbsp -Set.prototype.entries(): 返回键值对的遍历器
          <br />&nbsp&nbsp&nbsp&nbsp -Set.prototype.forEach(): 使用回调函数遍历每个成员
          <br />&nbsp&nbsp需要特别指出的是，Set的遍历顺序就是插入顺序
          <br />WeakSet：结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。
          <br />&nbsp&nbsp首先，WeakSet的成员只能是对象，而不能是其他类型的值。
          <br />&nbsp&nbsp其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用。因此WeakSet适合临时存放一组对象，以及存放跟对象绑定的信息。
          <br />&nbsp&nbsp另外因为垃圾回收机制何时运行是不可预测的，因此ES6规定WeakSet不可遍历。
          <br />&nbsp&nbspWeakSet结构有以下三个方法
          <br />&nbsp&nbsp&nbsp&nbsp -WeakSet.prototype.add(value)
          <br />&nbsp&nbsp&nbsp&nbsp -WeakSet.prototype.delete(value)
          <br />&nbsp&nbsp&nbsp&nbsp -WeakSet.prototype.has(value)
          <br />Map: 他类似于对象，也是键值对的集合，但是'键'的范围不限于字符串，各种类型的值(包括对象)都可以当做键。
          <br />&nbsp&nbspMap结构的实例有以下属性和操作方法
          <br />&nbsp&nbsp&nbsp&nbsp size属性： 返回Map结构成员的总数
          <br />&nbsp&nbsp&nbsp&nbsp -Map.prototype.set(key,value)
          <br />&nbsp&nbsp&nbsp&nbsp -Map.prototype.get(key)
          <br />&nbsp&nbsp&nbsp&nbsp -Map.prototype.has(key)
          <br />&nbsp&nbsp&nbsp&nbsp -Map.prototype.delete(key)
          <br />&nbsp&nbsp&nbsp&nbsp -Map.prototype.clear()
          <br />&nbsp&nbspMap结构原生提供三个遍历器生成函数和一个遍历方法
          <br />&nbsp&nbsp&nbsp&nbsp -Map.prototype.keys(): 返回键名的遍历器
          <br />&nbsp&nbsp&nbsp&nbsp -Map.prototype.values(): 返回键值的遍历器
          <br />&nbsp&nbsp&nbsp&nbsp -Map.prototype.entries(): 返回所有成员的遍历器
          <br />&nbsp&nbsp&nbsp&nbsp -Map.prototype.forEach(): 遍历Map的所有成员
          <br />&nbsp&nbsp需要特别注意的是，Map的遍历顺序就是插入顺序。
          <br />WeakMap： 结构与Map类似，也是用于生成键值对的集合。与Map有两点区别
          <br />&nbsp&nbsp首先，WeakMap只接受对象作为键名(null除外)，不接受其他类型的值做为键名。
          <br />&nbsp&nbsp其次，WeakMap的键名所指向的对象，不计入垃圾回收机制,因此 WeakMap没有遍历操作。
          <br />&nbsp&nbspWeakMap只有四个方法可用： get()、set()、has()、delete()`
        }],
        browser: [{
          q: '强缓存和协商缓存',
          a: `强缓存
              <br />强是强制的意思，当浏览器去请求文件时，服务端就在response header里面对该文件做了缓存配置(缓存的时间，缓存类型)，
              <br />出现在 response header 的 cache-control，常见设置是 max-age,public,private,no-cache,no-store等
              <br />cache-control: max-age=xxx,public/private/immutable  缓存有效时间xxx,客户端和代理服务器都可缓存/客户端可缓存,代理服务器不缓存/客户端可缓存
              <br />cache-control: no-cache/no-store 跳过设置强缓存但不妨碍设置协商缓存/不缓存
              <br />协商缓存
              <br />客户端请求时发现强缓存设置的时间过期后，就会去请求服务器，这就是协商缓存
              <br />设置线上缓存，response header里设置
              <br />etag: '5c20abbd-e2e8'  每个文件有一个，即文件hash
              <br />last-modified: Mon ,24 dec 2020 09:49:49 GMT  文件修改时间，精确到秒
              <br />协商过程： 发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->没过期-->返回304状态码-->客户端用缓存的老资源
              <br /><div style='text-indent:150px'>-->过期-->服务器返回新的资源，并更新last-modified</div>`

        },{
          q: '浏览器的事件传播机制',
          a: `事件传播分为三个阶段：捕获，目标对象，冒泡。其中捕获是事件对象从window派发到目标对象父级的过程；目标阶段是事件对象派发到目标元素时的阶段，如果事件类型
              <br />指示不冒泡，那事件传播在此阶段终止；冒泡和捕获相反是以目标对象父级到window的过程。`
        }, {
          q: 'cookie、session和token',
          a: `Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
              <br />session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。
              <br />token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个token并返回给客户端，以后客户端只需要带上这个token来请求数据即可。
              <br />cookie与session的区别：
              <br />1.cookie数据存放在客户端上，session数据存放在服务器上
              <br />2.cookie不是很安全，别人可以分析存放在本地的cookie并进行欺骗，考虑到安全应当使用session
              <br />3.session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE
              <br />4.单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie
              <br />5.将登陆信息等重要信息存放为SESSION，其他信息如果需要保留，可以放在COOKIE中
              <br />session与token的区别:
              <br />1.session: 我发给你一张身份证，但只是一张写着身份证号码的纸片。你每次来办事，我去后台查一下你的 id 是不是有效。
              <br />2.token: 我发给你一张加密的身份证，以后你只要出示这张卡片，我就知道你一定是自己人。`
        }, {
          q: 'sessionstorage和localstorage',
          a: `<div><img src="./cookie.jpg"></div>
              可通过window.sessionstorage和window.localstorage在js中操作这两个对象
              <br />sessionstorage.setitem/getitem/removeitem
              <br />localstorage.setitem/getitem/removeitem`
        }, {
          q: 'http 三次握手 四次挥手',
          a: `三次握手
              <br />1.客户端向服务端发送一个数据包，告诉服务器需要建立连接
              <br />2.服务端收到客户端发送的数据包之后，会返回一个数据包，通知客户端，我已经收到你的连接请求
              <br />3.客户端收到服务端返回的信息后，知道服务端已经准备好建立连接，但是还需要在发送一个数据包给服务端用于告诉服务端我已经收到你的回复。
              <br />为什么一定要三次？
              <br />主要还是因为存在数据可能丢失的问题，也就是说不管是客户端或者服务端，都不能确定自己发出的信息对方有没有正常接收到，所以需要对方发送一个回复信息。用于确定自己发出的信息已经被对方正常接收。
              <br />四次挥手
              <br />1.第一次挥手：client发送一个FIN，用来关闭client到server的数据传输，client进入FIN_WAIT_1状态；
              <br />2.第二次挥手：server收到FIN后，发送一个ACK给client，确认序号为收到序号+1，server进入CLOSE_WAIT状态；
              <br />3.第三次挥手：server发送一个FIN，用来关闭server到client的数据传输，server进入LAST_ACK状态
              <br />4.第四次挥手：client收到FIN后，client进入TIME_WAIT状态，接着发送一个ACK给server，确认序号为收到序号+1，server进入CLOSE状态。
              <br />为什么关闭连接需要四次挥手？
              <br />这是因为当收到对方的FIN报文时，仅仅表示对方不再发送数据了，但是还能接收数据。己方也未必全部将数据都发送给对方了，所以己方可以立即CLOSE，也可以发送一个数据给对方后，再发送FIN报文给对方表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送
              <div><a href="https://zhuanlan.zhihu.com/p/143064192?from_voters_page=true" style="font-size:12px">参考连接</div>`
        }, {
          q: 'BOM对象模型',
          a: `screen、window、navigator、location、document、history`
        }, {
          q: 'Location对象属性',
          a: `1.hash 设置或返回从#开始的URL
              <br />2.host 设置或返回主机名和当前URL的端口号
              <br />3.hostname 设置或返回当前URL的主机名
              <br />4.href 设置或返回完整的URL
              <br />5.pathname 设置或返回当前URL的路径部分
              <br />6.port 设置或返回当前URL的端口号
              <br />7.search 设置或返回从？开始的URL(查询部分)`
        }, {
          q: '前端性能优化',
          a: `1.减少http请求
              <br />&nbsp&nbsp(1)合并图片(精灵图)。
              <br />&nbsp&nbsp(2)合并压缩css样式表和js脚本。
              <br />&nbsp&nbsp(3)去掉不必要的请求。开发些代码或者系统升级之后残留的无效请求连接。
              <br />&nbsp&nbsp(4)充分里用缓存。这里是指客户端缓存或者说浏览器缓存。
              <br />2.图片优化
              <br />&nbsp&nbsp(1)尽可能使用PNG格式图片，它相对来说体积较小
              <br />&nbsp&nbsp(2)对于不同格式的图片，在上线之前最好进行一定的优化
              <br />&nbsp&nbsp(3)图片延迟加载，也叫懒加载
              <br />3.使用CDN。CND即内容分发网络，可以使用户就近取得所需内容，解决网络拥挤状况，提高用户访问网站的响应速度
              <br />4.开启GZIP。GZIP即数据压缩，用与压缩使用Internet传输的所有文本资源。开启GZIP的方法即到对应的web服务配置文件中设置一下即可
              <br />5.样式表和JS文件的优化。一般将css文件放在头部(head)标签中，js文件放在页面尾部
              <br />6.使用无cookie域名。
              <br />7.前端代码结构的优化
              <div><a href='https://www.html.cn/qa/other/21727.html'>参考连接</a></div>`
        },{
          q:'从浏览器多进程到JS单进程，JS运行机制梳理',
          a: `<div><a href='https://www.cnblogs.com/dailc/p/8325991.html'></div>`
        },{
          q: 'CSRF攻击',
          a: `CSRF（Cross-site request forgery）,中文名称：跨站请求伪造
              <div><a href='https://www.bilibili.com/video/BV1iW411171s'>参考连接</a></div>`
        },{
          q: 'tcp和udp',
          a: `udp：
              <br/>1.无连接；
              <br/>2.支持一对一，一对多，多对多和多对多交互通信；
              <br/>3.对应用层交付的报文直接打包；
              <br/>4.尽最大女里交付，也就是不可靠的；不使用流量控制和拥塞控制
              <br/>5.首部开销小，仅8字节
              <br/>tcp:
              <br/>1.面向连接；
              <br/>2.每一条TCP连接只能有两个端点EP，只能是一对一通信；
              <br/>3.面向字节流
              <br/>4.可靠传输，使用流量控制(滑动窗口)和拥塞控制(慢开始，拥塞避免，快重传，快恢复)
              <br/>5.首部最小20字节，最大60字节
              <div><img src='./tcp超时重传时间选算法.jpg' /></div>
              <div><img src='./tcp可靠传输的实现.jpg' /></div>
              <div><a href='https://www.bilibili.com/video/BV1c4411d7jb?p=61&spm_id_from=pageDriver'>视屏参考连接</a></div>`
        }],
        vue: [{
          q: 'v-if和v-show',
          a: 'v-if是决定该节点是否渲染，v-show是用样式决定显隐'
        }, {
          q: 'vue常用指令',
          a: `v-for、v-on、v-bind、v-if、v-show、v-model`
        }, {
          q: '生命周期',
          a: `beforeCreate: 创建前，此阶段为实例初始化，this指向创建的实例，此时的数据观察事件机制都未形成，不能获取DOM节点，data,computed,watch,methods上的方法和数据均不能访问
              <br />created：创建后，此阶段实例已经创建，完成数据的(data,pops,computed)的初始化导入依赖项，可以访问data,computed,watch,methods上的方法和数据
              <br />beforeMount：挂载前，虽然得不到具体的DOM元素，但vue挂载的根节点已经创建，下面vue对DOM的操作将围绕这个根元素继续进行
              <br />mounted：挂载，完成创建vm.$el，和双向绑定，完成挂载DOM和渲染，可在此函数中对挂载的DOM进行操作
              <br />beforeUpdate：数据更新前，数据驱动DOM，在数据更新后虽然没有立即更新视图，但DOM中的数据会改变，这是vue双向数据绑定的作用
              <br />updated：数据更新后，完成虚拟DOM的重新渲染和打补丁，组件DOM已完成更新，可执行依赖的DOM操作。不要在此函数中操作数据(修改属性)，会陷入死循环
              <br />beforeDestroy：销毁前，可做一些删除提示
              <br />destroyed：销毁后，当前组件已被删除，无法操作里面任何东西
              <div><a href='https://zhuanlan.zhihu.com/p/94601709'>生命周期函数具体适合场景</a></div>`
        }, {
          q: '双向绑定原理',
          a: `1.vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的， 也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；
              <br />2.核心：关于VUE双向数据绑定，其核心是 Object.defineProperty()方法；
              <br />3.介绍一下Object.defineProperty()方法
              <br />&nbsp&nbsp（1）Object.defineProperty(obj, prop, descriptor) ，这个语法内有三个参数，分别为 obj （要定义其上属性的对象） prop （要定义或修改的属性） descriptor （具体的改变方法）
              <br />&nbsp&nbsp（2）简单地说，就是用这个方法来定义一个值。当调用时我们使用了它里面的get方法，当我们给这个属性赋值时，又用到了它里面的set方法;
              <div>
                <a href='https://www.jianshu.com/p/e7ebb1500613' style='font-size:12px'>参考连接1</a> 
                <a href="https://www.jianshu.com/p/1b75a3623d0d" style='font-size:12xp;'>参考连接2</a>
                <a href="https://zhuanlan.zhihu.com/p/35348264">参考连接3</a>
              </div>
              `
        }, {
          q: '组件传值',
          a: `1.父子组件,子组件靠props接收父组件的传值，用$emit出发事件来传值给父组件
              <br />2.兄弟组件传值，通过bus，new一个vue实例(bus)做连接两个组件的中央事件总线，在都通过bus.$emit(fuc,msg)来传递,通过bus.$on(fuc,fuc(msg))监听事件来处理传递值
              <br />//bus实例
              <br />import Vue from 'vue'
              <br />export default new Vue()
              <br />3.$refs 的使用方法就是在元素或组件标签上添加ref属性指定一个引用信息，引用信息将会注册在父组件的$refs对象上，在js中使用$refs来指向DOM元素或组件实例
              <br />4.通过vuex`
        }, {
          q: 'nextTick()',
          a: `1.异步说明
              <br />&nbsp&nbsp&nbsp&nbsp Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。
              <br />2.事件循环说明
              <br />&nbsp&nbsp&nbsp&nbsp 简单来说，Vue在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。
              <br />由于Vue DOM更新是异步执行的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。
              <br />&nbsp&nbsp&nbsp&nbsp为了确保得到更新后的DOM，所以设置了 Vue.nextTick()方法。
              <div><a href="https://zhuanlan.zhihu.com/p/174396758" style='font-size:12px;'>参考连接</a></div>`
        },{
          q: `vue-router钩子函数`,
          a: `路由钩子有三种：
              <br/>1.全局钩子函数: beforeEach,afterEach,beforeResolve
              <br/>2.单个路由里面的钩子： beforeEnter
              <br/>3.组件路由： beforeRouteEnter,beforeRouteUpdate,beforeRouteLeave
              <br/>每个守卫方法接收三个参数：
              <br/> ①to： Route即将要进入的目标路由对象
              <br/> ②from： Route当前导航正要离开的路由
              <br/> ③next： Function 这是一个必须要调用的方法，执行效果依赖next方法的调用参数
              <br/>&nbsp&nbspnext参数：
              <br/>&nbsp&nbsp&nbsp&nbsp next()： 进行管道中的下一个钩子。如果钩子全部执行完了，则导航的状态就是comfirmed
              <br/>&nbsp&nbsp&nbsp&nbsp next(false): 终端当前的导航。如果浏览器的URL改变了，那么URL地址会重置到from路由对应的地址
              <br/>&nbsp&nbsp&nbsp&nbsp next('/')或者next({path: '/'}): 跳转到一个不同的地址
              <br/>&nbsp&nbsp&nbsp&nbsp next(error): 如果传入的参数是一个Error实例，则导航会被终止且改错误会被传递给router.onError()注册过的回调
              <br/>完整的导航解析流程：
              <br/>1.导航被触发
              <br/>2.在失活的组件里调用beforeRouteLeave守卫
              <br/>3.调用全局的beforeEach守卫
              <br/>4.在重用的组件里调用beforeRouteUpdate守卫
              <br/>5.在路由配置里调用beforeEnter
              <br/>6.解析异步路由组件
              <br/>7.在被激活的组件里调用beforeRouteEnter
              <br/>8.调用全局的beforeResolve
              <br/>9.导航被确认
              <br/>10.调用全局的afterEach
              <br/>11.触发DOM更新
              <br/>12.用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数
              <div><a href="https://www.jianshu.com/p/ddcb7ba28c5e">参考连接</a></div>`
        },{
          q: 'vue面试题',
          a: '<div><a href="https://zhuanlan.zhihu.com/p/92407628" style="font-size:12px">参考连接</div>`'
        },{
          q: 'vue2和vue3的不同',
          a: `<div><a href="https://blog.csdn.net/weixin_44475093/article/details/112386778" style="font-size:12px">参考连接</div>`
        }]
      },
      methods: {
        showans(e) {
          console.log($(e.target))
          $(e.target).parents(".box").find('.answers').slideToggle()
        },
        showall() {
          $('.box .answers').slideToggle()
        }
      }
    })
  </script>
</body>

</html>